可缓存性
public HTTP请求返回的过程当中,返回的内容经过的任何地方(代理服务器/发送请求的客户端浏览器等)都可以缓存
private 只有发起请求的浏览器才可以进行缓存
no-cache 任何节点都不可以进行缓存(可以在proxy服务器进行一个缓存,每次发起请求都要去服务器验证,如果服务器告诉我可以使用,才可以使用本地的缓存)

到期
max-age = <seconds> 过期后浏览器才会再次发送请求到服务器端再去请求新的内容
下面这两个基本用不到↓↓
s-maxage = <seconds> 代替max-age,但只有在代理服务器内才会生效。在浏览器端的话，浏览器还是会读取max-age作为缓存时间。
                     在代理服务器如果max-age和s-maxage都设置了的话，代理服务器会读取s-maxage，因为s-maxage是专门为代理服务器设置的
max-stale = <seconds> max-stale是发起请求方带的头,代表即便缓存过期,但是在max-stale这个时间内,还可以使用过期的缓存,不用去服务器请求,max-stale在浏览器是用不到的,只有在发起端设置才有用,在服务返回端设置没有任何用

重新验证
must-revalidate:如果设置max-age缓存中,如果已经过期,那么必须去原服务端发送请求,重新获取这部分数据,再来验证是不是过期了,而不能直接使用本地的缓存
proxy-revalidate 用在缓存服务器中,指定缓存服务器必须在过期的时候必须去原服务器上重新请求一遍,而不能直接使用本地的缓存
不太会用到↑↑

其他
no-store 与no-cache有区分,no-store彻底本地和代理服务器都不可以存储缓存,永远都要去服务器拿新的内容
no-transform 告诉代理服务器不要随便改变返回的内容

这些头都只是一个限制性,声明性的作用,没有任何强制的约束力,我们只是希望对于代理服务器的一些头它们按照这个规范去做,但是它们完全可以不按照这个规范去做
打包完的js文件后不同的hash码用来刷新缓存

浏览器基本用到cache-control的设置就是
public/private/no-cache
max-age
must-revalidate可能会用到 但不常见